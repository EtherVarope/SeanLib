//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18052
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace SeanLib.Core
{
    public static class GameObjectUtilities
    {
        /// <summary>
        /// ???????????Bounds???
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static Bounds GetBoundsWithChildren(this GameObject obj)
        {
            Renderer[] componentsInChildren = obj.GetComponentsInChildren<Renderer>();
            if (componentsInChildren.Length == 0)
                throw new Exception("no child in this gameobject");
            Vector3 min = componentsInChildren[0].bounds.min;
            Vector3 max = componentsInChildren[0].bounds.max;
            for (int i = 1; i < componentsInChildren.Length; i++)
            {
                var componentsInChild = componentsInChildren[i];
                if (componentsInChild.bounds.min.x < min.x)
                    min.x = componentsInChild.bounds.min.x;
                if (componentsInChild.bounds.min.y < min.y)
                    min.y = componentsInChild.bounds.min.y;
                if (componentsInChild.bounds.min.z < min.z)
                    min.z = componentsInChild.bounds.min.z;

                if (componentsInChild.bounds.max.x > max.x)
                    max.x = componentsInChild.bounds.max.x;
                if (componentsInChild.bounds.max.y > max.y)
                    max.y = componentsInChild.bounds.max.y;
                if (componentsInChild.bounds.max.z > max.z)
                    max.z = componentsInChild.bounds.max.z;
            }
            Bounds bounds = new Bounds((min + max) / 2, new Vector3(Math.Abs(min.x - max.x), Math.Abs(min.y - max.y), Math.Abs(min.z - max.z)));
            return bounds;
        }
        /// <summary>
        /// ???????????
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static bool IsActive(this GameObject obj)
        {
            return obj && obj.activeInHierarchy;
        }
        /// <summary>
        /// ???Parent GameObject
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static GameObject Parent(this GameObject obj)
        {
            if (obj == null || obj.transform.parent == null)
                return null;
            return obj.transform.parent.gameObject;
        }
        /// <summary>
        /// ?????????DestroyImmediate??????????
        /// </summary>
        /// <param name="parent"></param>
        public static void ClearChildrenImmediate(this GameObject parent)
        {
            List<GameObject> children = new List<GameObject>();
            foreach (Transform child in parent.transform)
            {
                children.Add(child.gameObject);
            }
            foreach (GameObject child in children)
            {
                GameObject.DestroyImmediate(child);
            }
        }
        /// <summary>
        /// Destroy????????
        /// </summary>
        /// <param name="parent"></param>
        public static void ClearChildren(this GameObject parent)
        {
            List<GameObject> children = new List<GameObject>();
            foreach (Transform child in parent.transform)
            {
                children.Add(child.gameObject);
            }
            foreach (GameObject child in children)
            {
                GameObject.Destroy(child);
            }
        }
        /// <summary>
        /// ?????????GameObject??????????
        /// </summary>
        /// <param name="parent"></param>
        /// <returns></returns>
        public static GameObject AddEmptyGameObject(this GameObject parent)
        {
            GameObject obj = new GameObject();
            obj.transform.parent = parent.transform;
            obj.transform.localPosition = Vector3.zero;
            obj.transform.localScale = Vector3.one;
            obj.transform.localRotation = Quaternion.identity;
            return obj;
        }
        /// <summary>
        /// ????????GameObject??????????
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="src">????????????</param>
        /// <returns></returns>
        public static GameObject AddInstantiate(this GameObject parent, GameObject src)
        {
            return AddInstantiate(parent, src, Vector3.zero, Vector3.one, Quaternion.identity);
        }
        /// <summary>
        /// ????????GameObject??????????
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="src">????????????</param>
        /// <param name="position"></param>
        /// <param name="scale"></param>
        /// <param name="quaternion"></param>
        /// <param name="withParentLayer"></param>
        /// <returns></returns>
        public static GameObject AddInstantiate(this GameObject parent, GameObject src, Vector3 position, Vector3 scale, Quaternion quaternion, bool withParentLayer = true)
        {
            GameObject obj = GameObject.Instantiate(src) as GameObject;
            obj.transform.parent = parent.transform;
            obj.transform.localPosition = position;
            obj.transform.localScale = scale;
            obj.transform.localRotation = quaternion;
            if (withParentLayer) SetLayerWidthChildren(obj, parent.layer);
            return obj;
        }
        /// <summary>
        /// ????????????????
        /// </summary>
        /// <param name="parent"></param>
        /// <returns></returns>
        public static List<GameObject> GetChildren(this GameObject parent)
        {
            List<GameObject> list = new List<GameObject>();
            foreach (Transform child in parent.transform)
            {
                list.Add(child.gameObject);
            }
            return list;
        }
        /// <summary>
        /// ???????????????
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="name"></param>
        /// 
        /// <returns></returns>
        public static GameObject GetChildByName(this GameObject parent, string name)
        {
            foreach (Transform child in parent.transform)
            {
                if (child.gameObject.name == name)
                    return child.gameObject;
            }
            return null;
        }
        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <param name="child"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public static GameObject GetParentByName(this GameObject child, string name)
        {
            if (child.name == name)
                return child;
            else if (child.transform.parent != null)
                return GetParentByName(child.transform.parent.gameObject, name);
            else
                return null;
        }
        /// <summary>
        /// ?????????????
        /// </summary>
        /// <param name="child"></param>
        /// <param name="parent"></param>
        /// <returns></returns>
        public static bool IsChildBy(this GameObject child, GameObject parent)
        {
            foreach (Transform componentInChild in parent.GetComponentsInChildren<Transform>())
            {
                if (componentInChild.gameObject == child)
                    return true;
            }
            return false;
        }
        /// <summary>
        /// ??????child???child??child?��??????????????????
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public static Transform GetChildByNameRecursion(this Transform parent, string name)
        {
            Transform t = parent.transform.Find(name);
            if (t == null)
            {
                for (int i = 0; i < parent.transform.childCount; i++)
                {
                    t = GetChildByNameRecursion(parent.transform.GetChild(i), name);
                    if (t != null)
                        return t;
                }
                return null;
            }
            else
            {
                return t;
            }
        }
        public static void ForEach(this Transform root,Action<Transform>childAction)
        {
            foreach (var child in root)
            {
                childAction((Transform)child);
            }
        }

        /// <summary>
        /// ?????????layer?????????��???????)
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="layer"></param>
        public static void SetLayerWidthChildren(this GameObject parent, int layer)
        {
            foreach (Transform componentInChild in parent.GetComponentsInChildren<Transform>())
            {
                componentInChild.gameObject.layer = layer;
            }
        }
        /// <summary>
        /// ????????????????????
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="camera"></param>
        public static void SetLayerToCameraCullingMask(this GameObject obj, Camera camera)
        {
            if (camera.cullingMask == 0) return;
            int currLayer = 1 << obj.layer;
            int uiCameraCullingMask = camera.cullingMask;
            if ((currLayer & uiCameraCullingMask) == 0)
            {
                for (int i = 0; i < 100; i++)
                {
                    if (((1 << i) & uiCameraCullingMask) != 0)
                    {
                        obj.SetLayerWidthChildren(i);
                        break;
                    }
                }
            }
        }
        public static List<GameObject> FindSceneAllGameObjects()
        {
            var scene = SceneManager.GetActiveScene();
            if (!scene.isLoaded) return new List<GameObject>();
            var roots = scene.GetRootGameObjects();
            return FindAllGameObject(new List<GameObject>(roots));
        }
        public static List<T> FindSceneAllGameObjects<T>() where T : UnityEngine.Component
        {
            var scene = SceneManager.GetActiveScene();
            if (!scene.isLoaded) return new List<T>();
            var roots = scene.GetRootGameObjects();
            return FindAllComponent<T>(new List<GameObject>(roots));
        }

        public static List<GameObject> FindAllGameObject(List<GameObject> roots, Func<GameObject, bool> where=null)
        {
            List<GameObject> sceneObjects = new List<GameObject>();
            foreach (var go in roots)
            {
                if (go&& where!=null&& where(go))
                {
                    sceneObjects.Add(go);
                }
                Transform trans = go.transform;
                if (trans.childCount > 0)
                {
                    List<GameObject> children = new List<GameObject>();
                    for (int i = 0; i < trans.childCount; i++)
                    {
                        children.Add(trans.GetChild(i).gameObject);
                    }
                    sceneObjects.AddRange(FindAllGameObject(children, where));
                }
            }
            return sceneObjects;
        }
        public static List<T> FindAllComponent<T>(List<GameObject> roots) where T : UnityEngine.Component
        {
            List<T> sceneObjects = new List<T>();
            foreach (var go in roots)
            {
                T component = go.GetComponent<T>();
                if (component)
                {
                    sceneObjects.Add(component);
                }
                Transform trans = go.transform;
                if (trans.childCount > 0)
                {
                    List<GameObject> children = new List<GameObject>();
                    for (int i = 0; i < trans.childCount; i++)
                    {
                        children.Add(trans.GetChild(i).gameObject);
                    }
                    sceneObjects.AddRange(FindAllComponent<T>(children));
                }
            }
            return sceneObjects;
        }
    }
}

